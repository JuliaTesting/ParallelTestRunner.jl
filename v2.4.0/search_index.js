var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Main-Functions","page":"API Reference","title":"Main Functions","text":"","category":"section"},{"location":"api/#Test-Discovery","page":"API Reference","title":"Test Discovery","text":"","category":"section"},{"location":"api/#Argument-Parsing","page":"API Reference","title":"Argument Parsing","text":"","category":"section"},{"location":"api/#Worker-Management","page":"API Reference","title":"Worker Management","text":"","category":"section"},{"location":"api/#Configuration","page":"API Reference","title":"Configuration","text":"","category":"section"},{"location":"api/#Internal-Types","page":"API Reference","title":"Internal Types","text":"These are internal types, not subject to semantic versioning contract (could be changed or removed at any point without notice), not intended for consumption by end-users. They are documented here exclusively for ParallelTestRunner developers and contributors.","category":"section"},{"location":"api/#ParallelTestRunner.runtests","page":"API Reference","title":"ParallelTestRunner.runtests","text":"runtests(mod::Module, args::Union{ParsedArgs,Array{String}};\n         testsuite::Dict{String,Expr}=find_tests(pwd()),\n         init_code = :(),\n         init_worker_code = :(),\n         test_worker = Returns(nothing),\n         stdout = Base.stdout,\n         stderr = Base.stderr,\n         max_worker_rss = get_max_worker_rss())\nruntests(mod::Module, ARGS; ...)\n\nRun Julia tests in parallel across multiple worker processes.\n\nArguments\n\nmod: The module calling runtests\nARGS: Command line arguments. This can be either the vector of strings of the arguments, typically from Base.ARGS, or a ParsedArgs object, typically constructed with parse_args. When you run the tests with Pkg.test, the command line arguments passed to the script can be changed with the test_args keyword argument. If the caller needs to accept arguments too, consider using parse_args to parse the arguments first.\n\nSeveral keyword arguments are also supported:\n\ntestsuite: Dictionary mapping test names to expressions to execute (default: find_tests(pwd())). By default, automatically discovers all .jl files in the test directory and its subdirectories.\ninit_code: Code use to initialize each test's sandbox module (e.g., import auxiliary packages, define constants, etc).\ninit_worker_code: Code use to initialize each worker. This is run only once per worker instead of once per test.\ntest_worker: Optional function that takes a test name and init_worker_code if init_worker_code is defined and returns a specific worker. When returning nothing, the test will be assigned to any available default worker.\nstdout and stderr: I/O streams to write to (default: Base.stdout and Base.stderr)\nmax_worker_rss: RSS threshold where a worker will be restarted once it is reached.\n\nCommand Line Options\n\n--help: Show usage information and exit\n--list: List all available test files and exit\n--verbose: Print more detailed information during test execution\n--quickfail: Stop the entire test run as soon as any test fails\n--jobs=N: Use N worker processes (default: based on CPU threads and available memory)\nTESTS...: Filter test files by name, matched using startswith\n\nBehavior\n\nAutomatically discovers all .jl files in the test directory (excluding runtests.jl)\nSorts test files by runtime (longest-running are started first) for load balancing\nLaunches worker processes with appropriate Julia flags for testing\nMonitors memory usage and recycles workers that exceed memory limits\nProvides real-time progress output with timing and memory statistics\nHandles interruptions gracefully (Ctrl+C)\nReturns nothing, but throws Test.FallbackTestSetException if any tests fail\n\nExamples\n\nRun all tests with default settings (auto-discovers .jl files)\n\nusing ParallelTestRunner\nusing MyPackage\n\nruntests(MyPackage, ARGS)\n\nRun only tests matching \"integration\" (matched with startswith):\n\nusing ParallelTestRunner\nusing MyPackage\n\nruntests(MyPackage, [\"integration\"])\n\nDefine a custom test suite\n\nusing ParallelTestRunner\nusing MyPackage\n\ntestsuite = Dict(\n    \"custom\" => quote\n        @test 1 + 1 == 2\n    end\n)\n\nruntests(MyPackage, ARGS; testsuite)\n\nCustomize the test suite\n\nusing ParallelTestRunner\nusing MyPackage\n\ntestsuite = find_tests(pwd())\nargs = parse_args(ARGS)\nif filter_tests!(testsuite, args)\n    # Remove a specific test\n    delete!(testsuite, \"slow_test\")\nend\nruntests(MyPackage, args; testsuite)\n\nMemory Management\n\nWorkers are automatically recycled when they exceed memory limits to prevent out-of-memory issues during long test runs. The memory limit is set based on system architecture.\n\n\n\n\n\n","category":"function"},{"location":"api/#ParallelTestRunner.find_tests","page":"API Reference","title":"ParallelTestRunner.find_tests","text":"find_tests(dir::String) -> Dict{String, Expr}\n\nDiscover test files in a directory and return a test suite dictionary.\n\nWalks through dir and finds all .jl files (excluding runtests.jl), returning a dictionary mapping test names to expression that include each test file.\n\n\n\n\n\n","category":"function"},{"location":"api/#ParallelTestRunner.parse_args","page":"API Reference","title":"ParallelTestRunner.parse_args","text":"parse_args(args; [custom::Array{String}]) -> ParsedArgs\n\nParse command-line arguments for runtests. Typically invoked by passing Base.ARGS.\n\nFields of this structure represent command-line options, containing nothing when the option was not specified, or Some(optional_value=nothing) when it was.\n\nCustom arguments can be specified via the custom keyword argument, which should be an array of strings representing custom flag names (without the -- prefix). Presence of these flags will be recorded in the custom field of the returned ParsedArgs object.\n\n\n\n\n\n","category":"function"},{"location":"api/#ParallelTestRunner.filter_tests!","page":"API Reference","title":"ParallelTestRunner.filter_tests!","text":"filter_tests!(testsuite, args::ParsedArgs) -> Bool\n\nFilter tests in testsuite based on command-line arguments in args.\n\nReturns true if additional filtering may be done by the caller, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#ParallelTestRunner.addworker","page":"API Reference","title":"ParallelTestRunner.addworker","text":"addworker(; env=Vector{Pair{String, String}}(), init_worker_code = :(), exename=nothing, exeflags=nothing; color::Bool=false)\n\nAdd a single worker process. To add multiple workers, use addworkers.\n\nArguments\n\nenv: Vector of environment variable pairs to set for the worker process.\ninit_worker_code: Code use to initialize each worker. This is run only once per worker instead of once per test.\nexename: Custom executable to use for the worker process.\nexeflags: Custom flags to pass to the worker process.\ncolor: Boolean flag to decide whether to start julia with --color=yes (if true) or --color=no (if false).\n\n\n\n\n\n","category":"function"},{"location":"api/#ParallelTestRunner.addworkers","page":"API Reference","title":"ParallelTestRunner.addworkers","text":"addworkers(; env=Vector{Pair{String, String}}(), init_worker_code = :(), exename=nothing, exeflags=nothing, color::Bool=false)\n\nAdd X worker processes. To add a single worker, use addworker.\n\nArguments\n\nenv: Vector of environment variable pairs to set for the worker process.\ninit_worker_code: Code use to initialize each worker. This is run only once per worker instead of once per test.\nexename: Custom executable to use for the worker process.\nexeflags: Custom flags to pass to the worker process.\ncolor: Boolean flag to decide whether to start julia with --color=yes (if true) or --color=no (if false).\n\n\n\n\n\n","category":"function"},{"location":"api/#ParallelTestRunner.default_njobs","page":"API Reference","title":"ParallelTestRunner.default_njobs","text":"default_njobs()\n\nDetermine default number of parallel jobs.\n\n\n\n\n\n","category":"function"},{"location":"api/#ParallelTestRunner.ParsedArgs","page":"API Reference","title":"ParallelTestRunner.ParsedArgs","text":"ParsedArgs\n\nStruct representing parsed command line arguments, to be passed to runtests. ParsedArgs objects are typically obtained by using parse_args.\n\nFields are\n\njobs::Union{Some{Int}, Nothing}: the number of jobs\nverbose::Union{Some{Nothing}, Nothing}: whether verbose printing was enabled\nquickfail::Union{Some{Nothing}, Nothing}: whether quick fail was enabled\nlist::Union{Some{Nothing}, Nothing}: whether tests should be listed\ncustom::Dict{String,Any}: a dictionary of custom arguments\npositionals::Vector{String}: the list of positional arguments passed on the command line, i.e. the explicit list of test files (to be matches with startswith)\n\n\n\n\n\n","category":"type"},{"location":"api/#ParallelTestRunner.WorkerTestSet","page":"API Reference","title":"ParallelTestRunner.WorkerTestSet","text":"WorkerTestSet\n\nA test set wrapper used internally by worker processes. Base.DefaultTestSet detects when it is the top-most and throws a TestSetException containing very little information. By inserting this wrapper as the top-most test set, we can capture the full results.\n\n\n\n\n\n","category":"type"},{"location":"advanced/#Advanced-Usage","page":"Advanced Usage","title":"Advanced Usage","text":"This page covers advanced features of ParallelTestRunner for customizing test execution.","category":"section"},{"location":"advanced/#Customizing-the-test-suite","page":"Advanced Usage","title":"Customizing the test suite","text":"By default, runtests automatically discovers all .jl files in your test/ directory (excluding runtests.jl itself) using the find_tests function. You can customize which tests to run by providing a custom testsuite dictionary:\n\nusing ParallelTestRunner\nusing MyPackage\n\n# Manually define your test suite\ntestsuite = Dict(\n    \"basic\" => quote\n        include(\"basic.jl\")\n    end,\n    \"advanced\" => quote\n        include(\"advanced.jl\")\n        @test 40 + 2 â‰ˆ 42\n    end\n)\n\ncd(test_dir) do # hide\nruntests(MyPackage, ARGS; testsuite)\nend # hide","category":"section"},{"location":"advanced/#Filtering-Test-Files","page":"Advanced Usage","title":"Filtering Test Files","text":"You can also use find_tests to automatically discover test files and then filter or modify them. This requires manually parsing arguments so that filtering is only applied when the user did not request specific tests to run:\n\nusing ParallelTestRunner\nusing MyPackage\n\n# Start with autodiscovered tests\ncd(test_dir) do # hide\ntestsuite = find_tests(pwd())\n\n# Parse arguments\nargs = parse_args(ARGS)\n\nif filter_tests!(testsuite, args)\n    # Remove tests that shouldn't run on non-Windows systems\n    if !Sys.iswindows()\n        delete!(testsuite, \"advanced\")\n    end\nend\n\nruntests(MyPackage, args; testsuite)\nend # hide\n\nThe filter_tests! function returns true if no positional arguments were provided (allowing additional filtering) and false if the user specified specific tests (preventing further filtering).","category":"section"},{"location":"advanced/#Initialization-Code","page":"Advanced Usage","title":"Initialization Code","text":"Use the init_code keyword argument to runtests to provide code that runs before each test file. This is useful for:\n\nImporting packages\nDefining constants, defaults or helper functions\nSetting up test infrastructure\n\nusing ParallelTestRunner\nusing MyPackage\n\nconst init_code = quote\n    # Define a helper function available to all tests\n    function test_helper(x)\n        return x * 2\n    end\nend\n\ncd(test_dir) do # hide\nruntests(MyPackage, ARGS; init_code)\nend # hide\n\nThe init_code is evaluated in each test's sandbox module, so all definitions are available to your test files.","category":"section"},{"location":"advanced/#Worker-Initialization","page":"Advanced Usage","title":"Worker Initialization","text":"For most situations, init_code described above should be used. However, if the common code takes so long to import that it makes a notable difference to run before every testset, you can use the init_worker_code keyword argument in runtests to have it run only once at worker initialization. However, you will also have to import the directly-used functionality in your testset module using init_code due to the way ParallelTestRunner.jl creates a temporary module for each testset.\n\nThe example below is trivial and init_worker_code would not be necessary if this were used in a package, but it shows how it should be used. A real use-case of this is for tests using the GPUArrays.jl test suite; including it takes about 3s, so that 3s running before every testset can add a significant amount of runtime to the various GPU backend testsuites as opposed to running once when the runner is initally created.\n\nusing ParallelTestRunner\nusing MyPackage\n\nconst init_worker_code = quote\n    # Common code that's slow to import\n    function complex_common_test_helper(x)\n        return x * 2\n    end\nend\n\nconst init_code = quote\n    # ParallelTestRunner creates a temporary module to run\n    #  each testset. `init_code` runs in this temporary module,\n    #  but code from `init_worker_code` that will be directly\n    #  called in a testset must be explicitly included in the\n    #  module namespace.\n    import ..complex_common_test_helper\nend\n\ncd(test_dir) do # hide\nruntests(MyPackage, ARGS; init_worker_code, init_code)\nend # hide\n\nThe init_worker_code is evaluated once per worker, so all definitions can be imported for use by the test module.","category":"section"},{"location":"advanced/#Custom-Workers","page":"Advanced Usage","title":"Custom Workers","text":"For tests that require specific environment variables or Julia flags, you can use the test_worker keyword argument to runtests to assign tests to custom workers:\n\nusing ParallelTestRunner\nusing MyPackage\n\nfunction test_worker(name)\n    if name == \"needs_env_var\"\n        # Create a worker with a specific environment variable\n        return addworker(; env = [\"SPECIAL_ENV_VAR\" => \"42\"])\n    elseif name == \"needs_threads\"\n        # Create a worker with multiple threads\n        return addworker(; exeflags = [\"--threads=4\"])\n    end\n    # Return nothing to use the default worker\n    return nothing\nend\n\ntestsuite = Dict(\n    \"needs_env_var\" => quote\n        @test ENV[\"SPECIAL_ENV_VAR\"] == \"42\"\n    end,\n    \"needs_threads\" => quote\n        @test Base.Threads.nthreads() == 4\n    end,\n    \"normal_test\" => quote\n        @test 1 + 1 == 2\n    end\n)\n\nruntests(MyPackage, ARGS; test_worker, testsuite)\n\nThe test_worker function receives the test name and should return either:\n\nA worker object (from addworker) for tests that need special configuration\nnothing to use the default worker pool\n\nnote: Note\nIf your test suite uses both a test_worker function and init_worker_code as described in a prior section, test_worker must also take in init_worker_code as a second argument. You are responsible for passing it to addworker if your init_code depends on any init_worker_code definitions.","category":"section"},{"location":"advanced/#Custom-Arguments","page":"Advanced Usage","title":"Custom Arguments","text":"If your package needs to accept its own command-line arguments in addition to ParallelTestRunner's options, use parse_args with custom flags:\n\nusing ParallelTestRunner\nusing MyPackage\n\n# Parse arguments with custom flags\nargs = parse_args(ARGS; custom=[\"myflag\", \"another-flag\"])\n\n# Access custom flags\nif args.custom[\"myflag\"] !== nothing\n    println(\"Custom flag was set!\")\nend\n\n# Pass parsed args to runtests\ncd(test_dir) do # hide\nruntests(MyPackage, args)\nend # hide\n\nCustom flags are stored in the custom field of the ParsedArgs object, with values of nothing (not set) or Some(value) (set, with optional value).","category":"section"},{"location":"advanced/#Interactive-use","page":"Advanced Usage","title":"Interactive use","text":"Arguments can also be passed via the standard Pkg.test interface for interactive control. For example, here is how we could run the subset of test files that start with the name test_cool_feature in i) verbose mode, and ii) with a specific number of Julia threads enabled:\n\n# Start julia in an environment where `MyPackage.jl` is available\njulia --project\n\nusing Pkg\n\n# No need to start a fresh session to change threading\nPkg.test(\"MyPackage\"; test_args=`--verbose advanced`, julia_args=`--threads=auto`);\n\nAlternatively, arguments can be passed directly from the command line with a shell alias like the one below:\n\njltest --threads=auto -- --verbose test_cool_feature\n\nShell alias:\n\nfunction jltest {\n    julia=(julia)\n\n    # certain arguments (like those beginnning with a +) need to come first\n    if [[ $# -gt 0 && \"$1\" = +* ]]; then\n        julia+=(\"$1\")\n        shift\n    fi\n\n    \"${julia[@]}\" --startup-file=no --project -e \"using Pkg; Pkg.API.test(; test_args=ARGS)\" \"$@\"\n}","category":"section"},{"location":"advanced/#Best-Practices","page":"Advanced Usage","title":"Best Practices","text":"Keep tests isolated: Each test file runs in its own module, so avoid relying on global state between tests.\nUse init_code for common setup: Instead of duplicating setup code in each test file, use init_code to share common initialization. For long-running initialization, consider using init_worker_code so that it is run only once per worker creation instead of before each test.\nFilter tests appropriately: Use filter_tests! to respect user-specified test filters while allowing additional programmatic filtering.\nHandle platform differences: Use conditional logic in your test suite setup to handle platform-specific tests:\ntestsuite = find_tests(pwd())\nif Sys.iswindows()\n    delete!(testsuite, \"unix_specific_test\")\nend\nLoad balance the test files: ParallelTestRunner runs the tests files in parallel, ideally all test files should run for roughly the same time for better performance. Having few long-running test files and other short-running ones hinders scalability.\nUse custom workers sparingly: Custom workers add overhead. Only use them when tests genuinely require different configurations.","category":"section"},{"location":"#ParallelTestRunner.jl","page":"Home","title":"ParallelTestRunner.jl","text":"ParallelTestRunner.jl is a simple parallel test runner for Julia tests with automatic test discovery. It runs each test file concurrently in isolated worker processes, providing real-time progress output and efficient resource management.","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Basic-Setup","page":"Home","title":"Basic Setup","text":"Remove existing include statements from your test files. ParallelTestRunner will automatically discover and run all test files.\nUpdate your test/runtests.jl:\nusing MyPackage\nusing ParallelTestRunner\n\ncd(test_dir) do # hide\nruntests(MyPackage, ARGS)\nend # hide\n\nThat's it! ParallelTestRunner will automatically:\n\nDiscover all .jl files in your test/ directory (excluding runtests.jl)\nRun them in parallel across multiple worker processes\nDisplay real-time progress with timing and memory statistics","category":"section"},{"location":"#Running-Tests","page":"Home","title":"Running Tests","text":"Run tests using the standard Julia package testing interface:\n\njulia --project -e 'using Pkg; Pkg.test(\"MyPackage\")'\n\nOr from within Julia:\n\nusing Pkg\nPkg.test(\"MyPackage\")","category":"section"},{"location":"#Command-Line-Options","page":"Home","title":"Command Line Options","text":"You can pass various options to the runtests.jl script to control test execution:\n\njulia --project test/runtests.jl [OPTIONS] [TESTS...]","category":"section"},{"location":"#Available-Options","page":"Home","title":"Available Options","text":"--help: Show usage information and exit\n--list: List all available test files and exit\n--verbose: Print more detailed information during test execution (including start times for each test)\n--quickfail: Stop the entire test run as soon as any test fails\n--jobs=N: Use N worker processes (default: based on CPU threads and available memory)\nTESTS...: Filter test files by name, matched using startswith","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"# List all available tests\njulia --project test/runtests.jl --list\n\n# Run only tests matching \"integration\"\njulia --project test/runtests.jl integration\n\n# Run with verbose output and 4 workers\njulia --project test/runtests.jl --verbose --jobs=4\n\n# Run with quick-fail enabled\njulia --project test/runtests.jl --quickfail","category":"section"},{"location":"#Using-with-Pkg.test","page":"Home","title":"Using with Pkg.test","text":"You can also pass arguments through Pkg.test:\n\nusing Pkg\nPkg.test(\"MyPackage\"; test_args=`--verbose --jobs=4 integration`)","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"#Automatic-Test-Files-Discovery","page":"Home","title":"Automatic Test Files Discovery","text":"ParallelTestRunner automatically discovers all .jl files in your test/ directory and subdirectories, excluding runtests.jl.","category":"section"},{"location":"#Parallel-Execution","page":"Home","title":"Parallel Execution","text":"Tests run concurrently in isolated worker processes, each inside own module. ParallelTestRunner records historical tests duration for each package, so that in subsequent runs long-running tests are executed first, to improve load balancing.","category":"section"},{"location":"#Real-time-Progress","page":"Home","title":"Real-time Progress","text":"The test runner provides real-time output showing:\n\nTest name and worker assignment\nExecution time\nGC time and percentage\nMemory allocation\nRSS (Resident Set Size) memory usage","category":"section"},{"location":"#Graceful-Interruption","page":"Home","title":"Graceful Interruption","text":"Press Ctrl+C to interrupt the test run. The framework will:\n\nClean up running tests\nDisplay a summary of completed tests\nExit gracefully","category":"section"},{"location":"#Test-File-Structure","page":"Home","title":"Test File Structure","text":"Your test files should be standard Julia test files using the Test standard library:\n\nusing Test\nusing MyPackage\n\n@testset \"MyPackage tests\" begin\n    @test 1 + 1 == 2\n    @test MyPackage.my_function(42) == 84\nend\n\nEach test file runs in its own isolated module, so you don't need to worry about test pollution between files.","category":"section"},{"location":"#Packages-using-ParallelTestRunner.jl","page":"Home","title":"Packages using ParallelTestRunner.jl","text":"There are a few packages already using ParallelTestRunner.jl to parallelize their tests, you can look at their setups if you need inspiration to move your packages as well:\n\nApproxFun.jl\nBlockArrays.jl\nCuNESSie.jl\nEnzyme.jl\nGPUArrays.jl\nGPUCompiler.jl\nHyperHessians.jl\nMetal.jl\nWCS.jl","category":"section"},{"location":"#Inspiration","page":"Home","title":"Inspiration","text":"Based on @maleadt test infrastructure for CUDA.jl.","category":"section"}]
}
